##
# @file gui.py
# @brief GUI handling for the main application.
#
# This module defines the graphical user interface components for the main application.
# It allows the user to sign a PDF document using a PIN entered by the user,
# and verify the digital signature of PDF documents using the user's RSA (4096-bit) public key.
# The application allows the user to choose the paths to the files containing the public key and the PDF document.
# The digital signature is generated by hashing the contents of the PDF document pages.
#
# Classes:
#     - Gui: The main GUI class that handles the user interface for signing PDF documents, verifying the digital signature of PDF documents,
#            and providing user feedback about the process results.
#
# Constants:
#     - MENU_STATE_MAIN: Indicates that the user is currently in the main menu.
#     - MENU_STATE_SIGNING: Indicates that the user is currently in the signing document menu.
#     - MENU_STATE_VERIFYING: Indicates that the user is currently in the verification document menu.
#     - PRIVATE_KEY_PATH: Describes the path to the file containing the user's private key.
#     - NO_SIGNATURE: Indicates that a digital signature does not exist in the PDF document.
#     - SIGNATURE_VERIFICATION_VALUE_ERROR: Indicates an error in signature verification.
#     - UNKNOWN_ERROR: Represents an unspecified error.
#     - INFO_ABOUT_SIGNING_DOCUMENT: Indicates that the message refers to signing the PDF document.
#     - INFO_ABOUT_VERIFYING_DOCUMENT: Indicates that the message refers to verifying the PDF document.
#     - PDF_FILE: Indicates that the file's extension is .pdf.
#     - PUBLIC_KEY_FILE: Indicates that the file's extension is .pem.
#
# Functions:
#    - checkIfPendriveSearched: Checks whether at least one pendrive is mounted and presents the user with the appropriate interface.
#    - detectPendriveAndReadPrivateKey: Checks whether at least one pendrive is mounted and reads the private key from it.
#    - resetMainMenu: Resets all GUI elements visible on the main menu.
#    - signFileMenu: Displays all GUI elements on the signing menu.
#    - verifyFileMenu: Displays all GUI elements on the verification menu.
#    - validatePin: Validates the entered PIN code (ensures it is a valid 8-digit number).
#    - selectFileLocation: Opens a dialog to select the location of the file containing the public key or the PDF document.
#    - updateMenuState: Checks whether the submit button should be enabled, based on whether all necessary values are entered.
#    - updateSignPdfFileMenuState: Checks whether the entered PIN is valid and whether the PDF document to sign is selected.
#    - updateVerifyPdfFileMenuState: Checks whether the file containing the public key and the PDF document to verify are selected.
#    - resetSignPdfFileMenu: Resets all GUI elements visible on the signing menu.
#    - resetVerifyPdfFileMenu: Resets all GUI elements visible on the verification menu.
#    - returnToMenu: Displays all GUI elements visible on the main menu and resets all flags.
#    - setLabelText: Sets the label text.
#    - showMessageBox: Displays a message box with the given parameters.
#    - signPdfMessageBox: Displays an appropriate message box based on the signing process result. 
#    - incorrectPinMessageBox: Displays a message box informing that the entered PIN is not valid.
#    - verifyPdfSuccessfullyMessageBox: Displays a message box informing that the verification process was successful.
#    - verifyPdfErrorMessageBox: Displays an appropriate message box based on an error during the verification process.
#    - signPdfFile: Signs the PDF document using a digital signature generated by hashing the contents of the PDF document pages.
#    - verifyPdfFile: Checks whether the digital signature in the PDF document is valid.
#  
import customtkinter as ctk, time
from utils.commonFunctions import searchForPendrive, searchAndReadPrivateKey
from main_application.signAndVerifyPDF import signPdfAndVerifyPin, verifyPdfFiles
from CTkMessagebox import CTkMessagebox

##
#@brief Indicates that the user is currently in the main menu.
MENU_STATE_MAIN = 1

##
#@brief Indicates that the user is currently in the signing document menu.
MENU_STATE_SIGNING = 2

##
#@brief Indicates that the user is currently in the verification document menu.
MENU_STATE_VERIFYING = 3

##
#@brief Describes the path to the file containing the user's private key.
PRIVATE_KEY_PATH = "Key/encrypted_PK.bin"

##
#@brief Indicates that a digital signature does not exist in the PDF document.
NO_SIGNATURE = 1

##
#@brief Indicates an error in signature verification.
SIGNATURE_VERIFICATION_VALUE_ERROR = 2

##
#@brief Represents an unspecified error.
UNKNOWN_ERROR = 3

##
#@brief Indicates that the message refers to signing the PDF document.
INFO_ABOUT_SIGNING_DOCUMENT = 1

##
#@brief Indicates that the message refers to verifying the PDF document.
INFO_ABOUT_VERIFYING_DOCUMENT = 2

##
#@brief Indicates that the file's extension is .pdf.
PDF_FILE = 1

##
#@brief Indicates that the file's extension is .pem.
PUBLIC_KEY_FILE = 2

ctk.set_appearance_mode("system")  
ctk.set_default_color_theme("blue")  

##
#@class Gui
#@brief The main GUI class that handles the user interface for signing PDF documents, verifying the digital signature of PDF documents,
#and providing user feedback about the process results.
#
#This class defines the GUI elements, such as buttons, labels, input fields, and combo boxes.
#It also handles validation of the entered PIN code and the paths to the files containing the public key and the PDF document..
#
class Gui(ctk.CTk):

    ## 
    # @brief The constructor of the class. Initializes the GUI components and sets up the layout.
    #
    # @details It creates all the GUI elements (buttons, labels, combo boxes) and arranges them in a window using the
    # pack geometry manager. Additionally, it initializes all flags and displays the main menu's GUI elements. Moreover, 
    # at the beginning, the application automatically detects the pendrive and loads the private key from it.
    #
    def __init__(self):
        super().__init__()
        self.title("Main application")
        self.geometry("600x600")

        self.vcmd = (self.register(self.validatePin),"%P")

        self.titleLabel = ctk.CTkLabel(self, text="Tool for Emulating\n the PAdES Qualified Electronic Signature", font=("Arial", 30))
        self.signFileMenuButton = ctk.CTkButton(self, width=280, height=70, text="Sign the PDF file", font=("Arial", 20), command=self.signFileMenu)
        self.verifyFileMenuButton = ctk.CTkButton(self, width=280, height=70, text="Verify the PDF file", font=("Arial", 20), command=self.verifyFileMenu)
        self.detectPendriveButton = ctk.CTkButton(self, width=280, height=70, text="Search pendrive again", font=("Arial", 20), command=self.checkIfPendriveSearched)
        self.infoAboutPendrive = ctk.CTkLabel(self, text="No pendrive detected\n or\n private key not found!\n\n Please try again!", font=("Arial", 30), text_color="red")

        self.inputLabel = ctk.CTkLabel(self, text="Input 8-digit PIN code", font=("Arial", 20))
        self.inputField = ctk.CTkEntry(self, show="*",validate="key" ,validatecommand=self.vcmd, width=280, height=30)
        self.inputFieldStatus = ctk.CTkLabel(self, text="")

        self.pdfFilePathButton = ctk.CTkButton(self, width=280, height=60, text="Select file path", font=("Arial", 20), command=lambda:self.selectFileLocation("Select the PDF file", [("PDF files", "*.pdf")], PDF_FILE))
        self.pdfFilePathInfo = ctk.CTkLabel(self, text="")

        self.publicKeyPathButton = ctk.CTkButton(self, width=280, height=60, text="Select public key path", font=("Arial", 20), command=lambda:self.selectFileLocation("Select the Public Key file", [("PEM files", "*.pem")], PUBLIC_KEY_FILE))
        self.publicKeyPathInfo = ctk.CTkLabel(self, text="")
        
        self.submitSignButton = ctk.CTkButton(self, width=280, height=60, text="Submit", font=("Arial", 20), command=self.signPdfFile)
        self.infoAboutSigningDocument = ctk.CTkLabel(self, text="", font=("Arial", 20))

        self.submitVerifyButton = ctk.CTkButton(self, width=280, height=60, text="Submit", font=("Arial", 20), command=self.verifyPdfFile)
        self.infoAboutVerifyingDocument = ctk.CTkLabel(self, text="", font=("Arial", 20))
        
        self.returnToMenuButton = ctk.CTkButton(self, width=180, height=40, text="Back", font=("Arial", 15), command=self.returnToMenu)

        self.pendrives = []
        self.privateKey = ""

        self.titleLabel.pack(pady=(40, 20))
        self.checkIfPendriveSearched()

        self.isPdfFileSelected = False
        self.isPublicKeySelected = False
        self.isValidPin = False
        self.menuState = MENU_STATE_MAIN

    ##
    #@brief Checks if a pendrive is detected and reads the private key from it. If the pendrive is found,
    # it hides the elements that allow user to detect the pendrive again, and then displays the elements of the main menu. 
    #
    def checkIfPendriveSearched(self):
        if self.detectPendriveAndReadPrivateKey():
            if self.infoAboutPendrive.winfo_ismapped():
                self.infoAboutPendrive.pack_forget()
            if self.detectPendriveButton.winfo_ismapped():
                self.detectPendriveButton.pack_forget()

            self.signFileMenuButton.pack(pady=(100,20))
            self.verifyFileMenuButton.pack(pady=(70.0))
        else:
            if self.signFileMenuButton.winfo_ismapped():
                self.signFileMenuButton.pack_forget()
            if self.verifyFileMenuButton.winfo_ismapped():
                self.verifyFileMenuButton.pack_forget()

            self.infoAboutPendrive.pack(pady=(80,20))
            self.detectPendriveButton.pack(pady=(50,0))

    ##
    # @brief Checks whether at least one pendrive is mounted and reads the private key from it.
    # 
    # @return Returns True if the private key is found, otherwise False.
    #                 
    def detectPendriveAndReadPrivateKey(self):
        self.pendrives = searchForPendrive()
        if len(self.pendrives) == 0:
            return False
        self.privateKey = searchAndReadPrivateKey(self.pendrives, PRIVATE_KEY_PATH)
        if self.privateKey != "Not found":
            return True
        return False

    ##
    # @brief Resets all GUI elements visible on the main menu.
    #
    def resetMainMenu(self):
        if self.signFileMenuButton.winfo_ismapped():
            self.signFileMenuButton.pack_forget()
        if self.verifyFileMenuButton.winfo_ismapped():
            self.verifyFileMenuButton.pack_forget()

    ##
    # @brief Displays all GUI elements on the signing menu. 
    # Additionally, it resets all GUI elements from the previous menu and updates the menu state flag.
    #
    def signFileMenu(self):
        self.menuState = MENU_STATE_SIGNING
        self.resetMainMenu()

        self.inputLabel.pack(pady=(15,0))
        self.inputField.pack(pady=(15,0))
        self.inputFieldStatus.pack(pady=(15,0))
        self.pdfFilePathButton.pack(pady=(15,0))
        self.pdfFilePathInfo.pack(pady=(15,0))
        self.submitSignButton.pack(pady=(15,0))
        self.infoAboutSigningDocument.pack(pady=(15,0))
        self.returnToMenuButton.pack(pady=(15,0))

        self.submitSignButton.configure(state="disabled")
        
    ##
    # @brief Displays all GUI elements on the verification menu. 
    # Additionally, it resets all GUI elements from the previous menu and updates the menu state flag.
    #
    def verifyFileMenu(self):
        self.menuState = MENU_STATE_VERIFYING
        self.resetMainMenu()

        self.pdfFilePathButton.pack(pady=(15,0))
        self.pdfFilePathInfo.pack(pady=(15,0))
        self.publicKeyPathButton.pack(pady=(15,0))
        self.publicKeyPathInfo.pack(pady=(15,0))
        self.submitVerifyButton.pack(pady=(15,0))
        self.infoAboutVerifyingDocument.pack(pady=(15,0))
        self.returnToMenuButton.pack(pady=(25,0))

        self.submitVerifyButton.configure(state="disabled")

    ##
    # @brief Validates the entered PIN code. The PIN must be a numeric string and should have a maximum length of 8 digits. 
    # The validation is used to enable or disable the submit button and provide feedback to the user regarding the validity of the PIN.
    # 
    # @param value The pin entered by the user.
    #
    # @return Returns True if the pin is valid, otherwise False.
    #  
    def validatePin(self, value):
        if value.isdigit() and len(value) <= 8:
            if len(value) == 8:
                self.inputFieldStatus.configure(text="PIN is valid.", font=("Arial", 20), text_color="green")
                self.isValidPin = True
                self.updateMenuState()
            else:
                self.inputFieldStatus.configure(text="PIN is invalid!", font=("Arial", 20), text_color="red")
                self.isValidPin = False
                self.updateMenuState()
            return True
        else:
            self.inputFieldStatus.configure(text="PIN is invalid!", font=("Arial", 20), text_color="red")
            self.isValidPin = False
            self.updateMenuState()
            return False

    ##
    # @brief Opens a dialog to select the location of the file containing the public key or the PDF document.
    # The parameter fileTypes specifies which file extensions can be selected.
    #
    # @param title The string containing the title of the dialog.
    # @param fileTypes A list of file extensions that can be selected.
    # @param type Indicates whether the dialog is open during verification or signing of a document.
    #     
    def selectFileLocation(self, title, filetypes, type):
        path = ctk.filedialog.askopenfilename(title=title, filetypes=filetypes)

        if path:
            if type == PDF_FILE:
                self.isPdfFileSelected = True
                self.pdfFilePathInfo.configure(text=f"Selected path:\n{path}", font=("Arial", 20))
            elif type == PUBLIC_KEY_FILE:
                self.isPublicKeySelected = True
                self.publicKeyPathInfo.configure(text=f"Selected path:\n{path}", font=("Arial", 20))
        else:
            if type == PDF_FILE:
                self.isPdfFileSelected = False
            elif type == PUBLIC_KEY_FILE:
                self.isPublicKeySelected = False

        self.updateMenuState()

    ##
    # @brief Checks whether the submit button should be enabled, based on whether all necessary values are entered.
    #
    def updateMenuState(self):
        if self.menuState == MENU_STATE_SIGNING:
            self.updateSignPdfFileMenuState()
        elif self.menuState == MENU_STATE_VERIFYING:
            self.updateVerifyPdfFileMenuState()

    ##
    # @brief Checks whether the sign PDF document button should be enabled.
    # Additionally, verifies if the entered PIN is valid and if the PDF document to sign is selected.
    #
    def updateSignPdfFileMenuState(self):
        if self.isValidPin and self.isPdfFileSelected:
            self.submitSignButton.configure(state="normal")
        else:
            self.submitSignButton.configure(state="disabled")

    ##
    # @brief Checks whether the verification PDF document button should be enabled.
    # Additionally, verifies if the file containing the public key and the PDF document to verify are selected.
    #
    def updateVerifyPdfFileMenuState(self):
        if self.isPdfFileSelected and self.isPublicKeySelected:
            self.submitVerifyButton.configure(state="normal")
        else:
            self.submitVerifyButton.configure(state="disabled")

    ##
    # @brief Resets all GUI elements visible on the signing menu. 
    # Additionally, it resets the input field visible on the signing menu.
    #
    def resetSignPdfFileMenu(self):
        self.inputField.configure(validate="none")  
        self.inputField.delete(0, "end")
        self.inputField.configure(validate="key" ,validatecommand=self.vcmd)
        self.inputFieldStatus.configure(text="")
        self.infoAboutSigningDocument.configure(text="")
            
        self.inputLabel.pack_forget()
        self.inputField.pack_forget()
        self.inputFieldStatus.pack_forget()
        self.pdfFilePathButton.pack_forget()
        self.pdfFilePathInfo.pack_forget()
        self.submitSignButton.pack_forget()
        self.infoAboutSigningDocument.pack_forget()
        self.returnToMenuButton.pack_forget()

    ##
    # @brief Resets all GUI elements visible on the verification menu. 
    #
    def resetVerifyPdfFileMenu(self):
        self.publicKeyPathInfo.configure(text="")
        self.infoAboutVerifyingDocument.configure(text="")

        self.pdfFilePathButton.pack_forget()
        self.pdfFilePathInfo.pack_forget()
        self.publicKeyPathButton.pack_forget()
        self.publicKeyPathInfo.pack_forget()
        self.submitVerifyButton.pack_forget()
        self.infoAboutVerifyingDocument.pack_forget()
        self.returnToMenuButton.pack_forget()

    ##
    # @brief Displays all GUI elements visible on the main menu and resets all flags.
    # Moreover, it resets the previous menu.
    # 
    def returnToMenu(self):
        self.isValidPin = False
        self.isPdfFileSelected = False
        self.isPublicKeySelected = False
        self.pdfFilePathInfo.configure(text="")

        if self.menuState == MENU_STATE_SIGNING:
            self.resetSignPdfFileMenu()     
        elif self.menuState == MENU_STATE_VERIFYING:
            self.resetVerifyPdfFileMenu()
        
        self.menuState = MENU_STATE_MAIN
        self.signFileMenuButton.pack(pady=(100,20))
        self.verifyFileMenuButton.pack(pady=(70.0))

    ##
    # @brief Sets the text of the label.
    #
    # @param newText The new text to be displayed on the label.
    # @param labelType The type of the label to update.
    # @param color (optional) The color of the label text. Defaults to a predefined color if not specified.
    #
    def setLabelText(self, newText, labelType, color=None):
        if labelType == INFO_ABOUT_SIGNING_DOCUMENT:
            self.infoAboutSigningDocument.configure(text=newText)
            if color:
                self.infoAboutSigningDocument.configure(text_color=color)
        elif labelType == INFO_ABOUT_VERIFYING_DOCUMENT:
            self.infoAboutVerifyingDocument.configure(text=newText)
            if color:
                self.infoAboutVerifyingDocument.configure(text_color=color)
        if newText != "":
            time.sleep(1)

    ##
    # @brief Displays a message box with the given parameters.
    #
    # @param title The string containing the title of the message box.
    # @param message The string containing information for the user.
    # @param option The option(s) available in the message box.
    # @param icon The icon to be displayed in the message box.
    #
    def showMessageBox(self, title, message, option, icon):
        CTkMessagebox(
            title=title,
            message=message,
            option_1=option,
            icon=icon
        )

    ##
    # @brief Displays an appropriate message box based on the signing process result.
    # 
    # @param result The outcome of the PDF document signing process.
    #
    def signPdfMessageBox(self, result):
        if result:
            self.showMessageBox("PDF Signing Completed Successfully", "The signed PDF file has been saved.", "OK", "check")
        else:
            self.showMessageBox("PDF Signing Failed", "An error occurred while signing the PDF file.", "Cancel", "cancel")

    ##
    # @brief Displays a message box informing that the entered PIN is not valid.
    #
    def incorrectPinMessageBox(self):
        self.showMessageBox("Incorrect PIN Entered", "The PIN you entered is incorrect. Please try again.", "Cancel", "cancel")
    
    ##
    # @brief Displays a message box informing that the verification process was successful.
    #
    def verifyPdfSuccessfullyMessageBox(self):
        self.showMessageBox("PDF Signature Verification", "The PDF signature has been successfully verified.", "OK", "check")

    ##
    # @brief Displays an appropriate message box based on an error during the verification process.
    #
    # @param errorType The error that occurred during the verification process. 
    # It can be one of the following: NO_SIGNATURE, SIGNATURE_VERIFICATION_VALUE_ERROR, or UNKNOWN_ERROR.
    #
    def verifyPdfErrorMessageBox(self, errorType):
        if errorType == NO_SIGNATURE:
            self.showMessageBox("PDF Signature Verification", "No signature found in the PDF document.", "Cancel", "cancel")
        elif errorType == SIGNATURE_VERIFICATION_VALUE_ERROR:
            self.showMessageBox("PDF Signature Verification", "The signature could not be verified due to an invalid value in the signature data.", "Cancel", "cancel")
        else:
            self.showMessageBox("PDF Signature Verification", "An unknown error occurred during PDF signature verification.", "Cancel", "cancel")

    ##
    # @brief Signs the PDF document using a digital signature generated by hashing the contents of the PDF document pages.
    #
    def signPdfFile(self):
        signPdfAndVerifyPin(self, self.privateKey, self.inputField.get(), self.pdfFilePathInfo.cget("text").split("\n")[1])

    ##
    # @brief Checks whether the digital signature in the PDF document is valid.
    #
    def verifyPdfFile(self):
        verifyPdfFiles(self, self.pdfFilePathInfo.cget("text").split("\n")[1], self.publicKeyPathInfo.cget("text").split("\n")[1])
