##
# @file signAndVerifyPDF.py
# @brief Module for signing PDF documents and verifying their digital signatures.
#
# This module provides functions for signing PDF documents using an RSA (4096-bit) private key
# and verifying the digital signatures of PDF documents using an RSA (4096-bit) public key.
# The digital signature is generated by hashing the contents of the PDF document pages.
#
# Constants:
#    - NO_SIGNATURE - Indicates that a digital signature does not exist in the PDF document.
#    - SIGNATURE_VERIFICATION_VALUE_ERROR - Indicates an error in signature verification.
#    - UNKNOWN_ERROR - Represents an unspecified error.
#    - OK - Indicates that the operation was successful.
#    - INFO_ABOUT_SIGNING_DOCUMENT - Indicates that the message refers to signing the PDF document.
#    - INFO_ABOUT_VERIFYING_DOCUMENT - Indicates that the message refers to verifying the PDF document.
#
# Functions:
#    - decryptPrivateKey: Decrypts an RSA (4096-bit) private key using the AES algorithm.
#    - verifyPin: Verifies if the entered PIN is correct.
#    - createHash: Generates a hash for the digital signature by hashing the contents of the PDF document pages.
#    - signPDF: Signs PDF documents and embeds the digital signature in the metadata of the PDF document.
#    - signPdfAndVerifyPin: Verifies if the PIN entered by the user is correct and provides user feedback about the signing result.
#    - verifyPdfSignatureFromMetadata: Checks whether the digital signature in the PDF document is valid.
#    - verifyPdfFiles: Provides user feedback about the verification result.
#    - checkPdfSignature: Checks whether the PDF document contains an embedded digital signature in its metadata.    
#    - modifyPDF: Adds a page to the PDF document to modify its content.
#
from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad
from hashlib import sha256
from Crypto.Signature import pkcs1_15
from Crypto.PublicKey import RSA
from Crypto.Hash import SHA256
from PyPDF2 import PdfReader, PdfWriter
import os, threading

##
#@brief Indicates that a digital signature does not exist in the PDF document.
NO_SIGNATURE = 1

##
#@brief Indicates an error in signature verification.
SIGNATURE_VERIFICATION_VALUE_ERROR = 2

##
#@brief Represents an unspecified error.
UNKNOWN_ERROR = 3

##
#@brief Indicates that the operation was successful.
OK = 4

##
#@brief Indicates that the message refers to signing the PDF document.
INFO_ABOUT_SIGNING_DOCUMENT = 1

##
#@brief Indicates that the message refers to verifying the PDF document.
INFO_ABOUT_VERIFYING_DOCUMENT = 2

##
# @brief Decrypts an RSA (4096-bit) private key using the AES algorithm.
#
# @param pin The PIN entered by the user.
# @param privateKey The user's RSA (4096-bit) private key.
#
# @return Returns the decrypted private key as bytes.
#
def decryptPrivateKey(pin, privateKey):
    iv = privateKey[:16]
    cipherText = privateKey[16:]

    hashedPin = sha256(pin.encode()).digest()

    cipher = AES.new(hashedPin, AES.MODE_CBC, iv)
    return unpad(cipher.decrypt(cipherText), AES.block_size)

##
# @brief Checks whether the PIN entered by the user is correct.
#
# @param pin The PIN entered by the user.
# @param privateKey The user's RSA (4096-bit) private key.
#
# @return Returns True if the PIN is correct, otherwise False.
#
def verifyPin(pin, privateKey):
    try:
        decryptedPrivateKey = decryptPrivateKey(pin, privateKey)

        if decryptedPrivateKey:
           return True
        else:
            return False
    except Exception as e:
        return False

##
# @brief Generates a hash for the digital signature by hashing the contents of the PDF document pages.
#
# @param pdfReader The PDF reader object used to access the document's contents.
#
# @return Returns the computed hash value.
#
def createHash(pdfReader):
    hash = SHA256.new()
    for page in pdfReader.pages:
        hash.update(page.extract_text().encode())
    return hash

##
# @brief Signs a PDF document and embeds the digital signature in its metadata.  
# The digital signature is generated by hashing the contents of the PDF document pages.
#
# @param gui The GUI object used to update the signing status in the user interface.
# @param privateKey The user's RSA (4096-bit) private key.
# @param pin The PIN entered by the user.
# @param pdfPath The path to the PDF document to be signed.
#
# @return Returns True if the signing process was successful, otherwise False.
#
def signPDF(gui, privateKey, pin, pdfPath):
    try:
        base, ext = os.path.splitext(pdfPath)
        signedPdfPath = f"{base}-signed.pdf"
        decryptedPrivateKey = RSA.import_key(decryptPrivateKey(pin, privateKey))

        gui.setLabelText("Opening the PDF file ...", INFO_ABOUT_SIGNING_DOCUMENT, "white")
        with open(pdfPath, "rb") as f:
            pdfReader = PdfReader(f)
            pdfWriter = PdfWriter()

            gui.setLabelText("Generating hash of the PDF file ...", INFO_ABOUT_SIGNING_DOCUMENT)
            pdfHash = createHash(pdfReader)

            gui.setLabelText("Creating a digital signature ...", INFO_ABOUT_SIGNING_DOCUMENT)
            signature = pkcs1_15.new(decryptedPrivateKey).sign(pdfHash)

            gui.setLabelText("Adding a signature to the PDF file ...", INFO_ABOUT_SIGNING_DOCUMENT)
            for page in pdfReader.pages:
                pdfWriter.add_page(page)

            pdfWriter.add_metadata({
                "/Signature": signature
            })

            gui.setLabelText("Saving the signed PDF file ...", INFO_ABOUT_SIGNING_DOCUMENT)
            with open(signedPdfPath, "wb") as signedPDF:
                pdfWriter.write(signedPDF)

            return True
    except Exception as e:
        print(f"Error signing PDF: {e}")
        return False

##
# @brief Verifies if the PIN entered by the user is correct and provides user feedback about the signing result.
#
# @param gui The GUI object used to update the signing status in the user interface.
# @param privateKey The user's RSA (4096-bit) private key.
# @param pin The PIN entered by the user.
# @param pdfPath The path to the PDF document to be signed.
#
def signPdfAndVerifyPin(gui, privateKey, pin, pdfPath):
    def signPdfThread():
        gui.setLabelText("Starting the PDF signing process ...", INFO_ABOUT_SIGNING_DOCUMENT)
        gui.setLabelText("Verifying PIN ...", INFO_ABOUT_SIGNING_DOCUMENT)
        
        if verifyPin(pin, privateKey):
            gui.setLabelText("PIN verified successfully", INFO_ABOUT_SIGNING_DOCUMENT, "green")
            if signPDF(gui, privateKey, pin, pdfPath):
                gui.setLabelText("", INFO_ABOUT_SIGNING_DOCUMENT)
                gui.signPdfMessageBox(True)
            else:
                gui.setLabelText("", INFO_ABOUT_SIGNING_DOCUMENT)
                gui.signPdfMessageBox(False)
        else:
            gui.setLabelText("", INFO_ABOUT_SIGNING_DOCUMENT)
            gui.incorrectPinMessageBox()

    threading.Thread(target=signPdfThread, daemon=True).start()

##
# @brief Checks whether the digital signature in the PDF document is valid.
# The user's RSA (4096-bit) public key is not required during this process.
#
# @param gui The GUI object used to update the verification status in the user interface.
# @param pdfPath The path to the PDF document to verify.
# @param publicKeyPath The path to the file that stores the user's public key.
#
# @return Returns OK if the process was successful.\n
#         Returns NO_SIGNATURE if the PDF document does not contain a digital signature.\n
#         Returns SIGNATURE_VERIFICATION_VALUE_ERROR if the digital signature is not valid.\n
#         Returns UNKNOWN_ERROR if an exception was encountered.\n
#
def verifyPdfSignatureFromMetadata(gui, pdfPath, publicKeyPath):
    try:
        gui.setLabelText("Reading the public key from file ...", INFO_ABOUT_VERIFYING_DOCUMENT)
        with open(publicKeyPath, "rb") as pub_file:
            public_key = RSA.import_key(pub_file.read())

        gui.setLabelText("Reading the PDF file ...", INFO_ABOUT_VERIFYING_DOCUMENT)
        with open(pdfPath, "rb") as f:
            pdfReader = PdfReader(f)
            metadata = pdfReader.metadata

            gui.setLabelText("Checking if signature exists in metadata ...", INFO_ABOUT_VERIFYING_DOCUMENT)
            if "/Signature" not in metadata:
                return NO_SIGNATURE

            signature = metadata["/Signature"]

            gui.setLabelText("Generating hash of the PDF file ...", INFO_ABOUT_VERIFYING_DOCUMENT)
            pdfHash = createHash(pdfReader)

            gui.setLabelText("Verifying the signature ...", INFO_ABOUT_VERIFYING_DOCUMENT)
            try:
                pkcs1_15.new(public_key).verify(pdfHash, signature)
                return OK
            except (ValueError, TypeError) as e:
                return SIGNATURE_VERIFICATION_VALUE_ERROR
    except Exception as e:
        print(f"Error verifying PDF signature: {e}")
        return UNKNOWN_ERROR

##
# @brief Provides user feedback about the verification result.
#
# @param gui The GUI object used to update the verification status in the user interface.
# @param pdfPath The path to the PDF document to verify.
# @param publicKeyPath The path to the file that stores the user's public key.
#
def verifyPdfFiles(gui, pdfPath, publicKeyPath):
    def verifyPdfThread():
        gui.setLabelText("Starting the PDF verification process ...", INFO_ABOUT_VERIFYING_DOCUMENT)

        result = verifyPdfSignatureFromMetadata(gui, pdfPath, publicKeyPath)
        gui.setLabelText("", INFO_ABOUT_VERIFYING_DOCUMENT)
        if result == OK:
            gui.verifyPdfSuccessfullyMessageBox()
        elif result == NO_SIGNATURE:
            gui.verifyPdfErrorMessageBox(NO_SIGNATURE)
        elif result == SIGNATURE_VERIFICATION_VALUE_ERROR:
            gui.verifyPdfErrorMessageBox(SIGNATURE_VERIFICATION_VALUE_ERROR)
        else:
            gui.verifyPdfErrorMessageBox(UNKNOWN_ERROR)

    threading.Thread(target=verifyPdfThread, daemon=True).start()

##
# @brief Checks if the PDF document contains an embedded digital signature in its metadata.    
#
# @param pdfPath The path to the PDF document to check.
#
# @return Returns True if the PDF document contains a digital signature, otherwise False.
#
def checkPdfSignature(pdfPath):
    try:    
        with open(pdfPath, "rb") as f:
            pdfReader = PdfReader(f)
            metadata = pdfReader.metadata

            if metadata and "/Signature" in metadata:
                print("Signature found in the PDF metadata:", metadata["/Signature"])
                return True
            else:
                print("No signature found in the PDF metadata.")
                return False
    except Exception as e:
        print(f"Error reading the PDF file: {e}")
        return False

##
# @brief Appends the first page of the PDF document to the end, modifying its content.
#
# @param pdfPath The path to the PDF document to be modified.
#
def modifyPdf(pdfPath):
    try:
        reader = PdfReader(pdfPath)
        writer = PdfWriter()

        signature = reader.metadata["/Signature"]

        for page in range(len(reader.pages)):
            writer.add_page(reader.pages[page])

        writer.add_page(reader.pages[0])

        writer.add_metadata({
            "/Signature": signature
        })

        with open(pdfPath, "wb") as f:
            writer.write(f)
    except Exception as e:
        print(f"Error modifying the PDF file: {e}")

#checkPdfSignature("")
#checkPdfSignature("")
#modifyPdf("")
